# Understanding Lazy Evaluation in Haskell

<div><div>
<p>The key thing about lazy evaluation in Haskell is that it doesn't affect the output of your program at all. You can read it just as if everything were evaluated as soon as it is defined, and you'll still get the same result.</p>
<p>Lazy evaluation is just a <em>strategy</em> for figuring out the value of an expression in the program. There are many possible and they all give the same result[1]; any evaluation strategy that <em>changes the meaning of the program</em> wouldn't be a valid strategy!</p>
<p>So from a certain perspective, you don't <em>have</em> to understand lazy evaluation (yet) if it's giving you trouble. When you're learning Haskell, especially if it's your first functional and pure language, thinking about expressing yourself in this way is much more important. I would also rate training yourself to become comfortable with reading Haskell's (often quite dense) syntax as more important than fully "grokking" lazy evaluation. So don't worry about it too much if the concept gives you difficulty.</p>
<p>That said, my go at explaining it is below. I haven't used your examples, as they're not really affected by lazy evaluation, and Owen has talked more clearly than I can about dynamic binding and delayed execution wrt your example.</p>
<hr />
<p>The most important difference between (valid) evaluation strategies is that some strategies can fail to return a result at all where another strategy might succeed. Lazy evaluation has the particular property that if any (valid) evaluation strategy can find a result, lazy evaluation will find it. In particular, programs that generate infinite data structures and then only use a finite amount of the data can terminate with lazy evaluation. In the strict evaluation you're probably used to, the program has to finish generating the infinite data structure before it can go on to use part of it, and of course it will.</p>
<p>The way lazy evaluation achieves this is by only evaluating something when it's needed to figure out what to do next. When you call a function that returns a list, it "returns" straight away and gives you a placeholder for the list. That placeholder can be passed to other functions, stored in other data structures, anything. Only when the program needs to know something about the list will it be actually evaluated, and only as far as needed.</p>
<p>Say the program now is going to do something different if the list is empty than if it is not. The the <strong>function call that originally returned the placeholder</strong> is evaluated a little bit further, to see if it returns an empty list or a list with a head element. Then the evaluation stops again, as the program now knows which way to go. If the rest of the list is never needed, it will never be evaluated.</p>
<p>But it's also not evaluated more times than needed. If the placeholder was passed into multiple functions (so it's now involved in other not-yet-evaluated function calls), or stored into several different data structures, Haskell still "knows" that they're all the same thing, and arranges for them all to "see" the effects of any further evaluation of the placeholder triggered from any of them. Eventually, if all of the list is needed somewhere, they'll all be pointing to an ordinary fully-evaluated data structure, and laziness has no further impact.</p>
<p>But the key thing to remember is that <strong>everything</strong> needed to produce that list is already determined and fixed when the placeholder was generated. It <strong>can't</strong> be affected by anything else that's happened in the program since. If that were not so, then Haskell would not be <strong>pure</strong>. And vice versa; impure languages can't have Haskell-style full laziness behind the scenes, because the results you would get could change dramatically depending on when <strong>in the future</strong> the results are needed. Instead, impure languages that support lazy evaluation tend to have it only for certain things explicitly declared by the programmer, with warnings in the manual saying "don't use laziness on something dependent on side effects".</p>
<hr />
<p>[1] I lie a little here. Keep reading below the line to see why.</p>
 </div>

## Related Links
[[Haskell-lazy-evaluation-2c5aa28e]]
[[Why-is-lazy-evaluation-useful--404e9606]]